## System Requirements Document: Agentic Intelligence Platform (Phase 2)

**Version:** 2.0 (Hackathon Agentic Layer)
**Date:** 2025-09-14

### 1. Introduction

#### 1.1 Purpose
This document specifies the system requirements for Phase 2 of the Agentic Creator Intelligence Platform. The purpose of this phase is to build a layer of AI-powered, autonomous agents on top of the foundational Creator CRM established in Phase 1. This will transform the application from a passive data management tool into a proactive, conversational intelligence partner that helps creators understand their audience and optimize their strategy.

#### 1.2 Scope
The scope of Phase 2 is to design, implement, and integrate the core agentic features. This includes:
- A primary user interface for interacting with the agentic system via natural language, inspired by the "Swarm Command" concept.
- A backend engine capable of interpreting user intent, generating multi-step action plans, and executing those plans against the local database.
- A set of specific agentic workflows for pre-campaign research and post-campaign analysis.

This phase assumes that all requirements from the Phase 1 SRD (data ingestion, core models for Profiles, Events, Campaigns, Tags, and manual attribution) have been successfully implemented.

#### 1.3 Definitions, Acronyms, and Abbreviations
- **Agent:** An AI-powered, autonomous system designed to perform specific tasks.
- **Swarm Command:** The primary natural language interface for issuing complex commands to the agentic system.
- **LLM:** Large Language Model. The core AI component for understanding intent and planning actions.
- **Tool / Function Calling:** The mechanism by which an LLM can request the execution of predefined, deterministic code functions to interact with the application's data and services.
- **Plan:** A sequence of tool calls generated by the LLM to fulfill a user's request.
- **Executor:** The backend component that runs the functions specified in the plan.
- **SSE:** Server-Sent Events. A technology for streaming real-time updates from the server to the client.

---

### 2. Overall Description

#### 2.1 Product Perspective
Phase 2 evolves the product from a "system of record" to a "system of intelligence." It introduces a conversational layer that allows the creator to "ask questions" of their data in a natural way. The platform will no longer just store data; it will actively analyze it, surface insights, and provide strategic recommendations, functioning as an autonomous research assistant for the creator.

#### 2.2 Product Functions
- **FR-5: Swarm Command Interface:** A modal or command bar for natural language queries.
- **FR-6: Agentic Backend Engine:** An LLM-based planner and a deterministic executor to translate language into database actions.
- **FR-7: Pre-Campaign Agent Workflow:** Agents that assist with content optimization and trend research before a campaign is launched.
- **FR-8: Post-Campaign Agent Workflow:** Agents that automate performance analysis and provide strategic insights after a campaign concludes.

#### 2.3 User Characteristics
The user remains the content creator or hackathon judge. The interaction model shifts from purely graphical (clicking, filtering) to a hybrid model that heavily features conversational interaction. The system must be designed to build user trust by making the agent's actions transparent and understandable.

#### 2.4 Assumptions & Dependencies
- All Phase 1 features and the underlying Prisma schema are complete and functional.
- The application has access to an external LLM API that supports robust function calling (e.g., OpenAI GPT-4, Google Gemini, Anthropic Claude 3).
- The local classifier service (`scripts/daniel_mock_api.py`) from the `ProfileIdentification` feature is available for agents to call upon as a tool.

---

### 3. Functional Requirements

#### FR-5: Swarm Command Interface

- **FR-5.1: UI Component:**
    - The system shall provide a "Swarm Command" button or a persistent command bar in the main UI.
    - Activating this component shall present a modal or view with a text input for the user to enter their natural language query.

- **FR-5.2: Natural Language Input Processing:**
    - The input field shall accept complex, multi-intent queries related to the creator's audience, campaigns, and tags (e.g., "Show me followers I gained from my last campaign who have 'UBC' as a tag and seem to be interested in golf").

- **FR-5.3: Plan Generation and Visualization:**
    - Upon submitting a query, the system shall immediately display a "Generating Plan..." status.
    - Once the plan is generated by the backend, the UI shall render it as a checklist of discrete, human-readable steps, mirroring the provided screenshot.

- **FR-5.4: Real-time Execution Feedback:**
    - The UI shall update the status of each step in the plan in real-time as the backend executes it.
    - Status indicators shall clearly distinguish between completed (âœ“), in-progress (ðŸ”„), queued, and failed (âŒ) steps.

- **FR-5.5: Actionable Output:**
    - The final step of a plan shall often be "Determine Next Best Action."
    - The result of this stepâ€”a strategic recommendation or summaryâ€”shall be clearly displayed to the user upon completion of the plan.

#### FR-6: Agentic Backend Engine

- **FR-6.1: LLM-Powered Planner:**
    - The system shall have a dedicated API route (e.g., `/api/swarm`) that receives the user's query.
    - This route shall forward the query and a description of available tools to a designated LLM with function-calling capabilities.
    - The LLM's response, a structured JSON object representing the plan, shall be parsed and validated by the backend.

- **FR-6.2: Tool Definition and Registration:**
    - The backend shall define a set of strongly-typed TypeScript functions that serve as "tools" for the LLM. Each tool will have a clear name and a description of its purpose, parameters, and return values.
    - The initial set of tools shall include, but not be limited to:
        - `find_profiles(filters: {tags?: string[], status?: string, event_history?: string})`: Finds profiles matching complex criteria.
        - `analyze_churn_patterns(campaign_id: number)`: Identifies common tags or attributes among users who unfollowed after a campaign.
        - `get_campaign_performance(campaign_id: number)`: Calculates and returns key metrics for a campaign.
        - `invoke_profile_classifier(username: string)`: Calls the local Python service to get inferred tags for a specific user.
        - `summarize_and_recommend(context: string, data: any[])`: The final tool that generates the "Next Best Action."

- **FR-6.3: Deterministic Executor:**
    - The backend shall iterate through the LLM-generated plan and execute each tool call sequentially.
    - The executor shall use the Prisma client to perform all database operations, ensuring type safety and consistency.
    - The output of one step shall be available as input to subsequent steps, allowing for complex data pipelines.

- **FR-6.4: Real-time State Streaming:**
    - The backend shall use Server-Sent Events (SSE) to push status updates for each step of the plan back to the client as they occur.

#### FR-7: Pre-Campaign Agent Workflow

- **FR-7.1: Content Optimization Agent:**
    - The system shall provide a UI where a user can input draft text for a campaign (e.g., a caption or description).
    - An agent shall analyze the text and provide suggestions to improve clarity, engagement, and alignment with the creator's brand voice, based on analysis of past successful content (if data is available).

- **FR-7.2: Trend and Hashtag Research Agent:**
    - When planning a campaign, a user shall be able to invoke an agent to research relevant trends.
    - The agent shall identify and suggest currently trending hashtags and accounts to mention that are relevant to the campaign's topic and target audience.

#### FR-8: Post-Campaign Agent Workflow

- **FR-8.1: Automated Performance Reporting Agent:**
    - After a campaign's end date, an agent shall automatically trigger a "Swarm Command" to generate a performance summary.
    - The report shall include key metrics such as new followers attributed to the campaign, churn rate of those new followers, and net audience growth.

- **FR-8.2: Intelligent Churn Analysis Agent:**
    - The system shall allow a user to ask, "Why did people from my last campaign unfollow me?"
    - An agent will execute a plan to:
        1. Identify all profiles who followed during the campaign window and later unfollowed.
        2. Invoke the profile classifier on these users.
        3. Identify common tags or characteristics among the churned audience.
        4. Present a summary of findings (e.g., "A significant portion of churned users were tagged with 'giveaway_hunter', suggesting low long-term interest.").

---

### 4. Non-Functional Requirements

- **NFR-1 (Performance):**
    - Plan generation via the LLM should complete within 5 seconds.
    - Real-time execution feedback streamed to the client must have a latency of less than 500ms after a step is completed on the backend.

- **NFR-2 (Usability & Trust):**
    - The plan visualization is critical. It must be clear, concise, and accurately reflect the agent's actions to build user trust.
    - Error messages for failed steps must be user-friendly and provide context.

- **NFR-3 (Extensibility):**
    - The tool registration system must be designed to be modular, allowing developers to easily add new capabilities (new functions for the LLM to use) without rewriting the core planner or executor.

- **NFR-4 (Privacy):**
    - All interactions with the local SQLite database must remain on the user's machine.
    - When sending data to an external LLM API, the system should minimize personally identifiable information (PII) where possible. For a hackathon, sending usernames is acceptable, but this should be noted as a consideration for a production system.

---

### 5. System Architecture Flow

A typical "Swarm Command" request will follow this data flow:

```
[User UI] --(1. Natural Language Query)--> [Next.js API Route: /api/swarm]
   ^                                                     |
   |                                                     | (2. Query + Tools)
   |                                                     v
   |                                                 [LLM API]
   |                                                     |
   |                                                     | (3. Structured Plan JSON)
   |                                                     v
   |                                                 [Agentic Executor]
   |                                                     |
   |                                                     | (4. Prisma Calls)
   |                                                     v
[SSE Connection for Real-time Updates] <--(6. Stream Status)-- [Local SQLite DB]
   |                                                     ^
   |                                                     | (5. Data Retrieval/Update)
   +-----------------------------------------------------+
```
